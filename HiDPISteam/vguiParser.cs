//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\Robert Hencke\\Documents\\vgui.g 2012-11-26 21:28:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class vguiParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGNMENT", "COMMENT", "GROUP", "HIDDEN", "STRING", "TAG", "WS", "'='", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int ASSIGNMENT=4;
	public const int COMMENT=5;
	public const int GROUP=6;
	public const int HIDDEN=7;
	public const int STRING=8;
	public const int TAG=9;
	public const int WS=10;

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false, false
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public vguiParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public vguiParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}
	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return vguiParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\Robert Hencke\\Documents\\vgui.g"; } }


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_start() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_start() {}

	// $ANTLR start "start"
	// C:\\Users\\Robert Hencke\\Documents\\vgui.g:14:8: public start : assignment EOF -> assignment ;
	[GrammarRule("start")]
	public AstParserRuleReturnScope<object, IToken> start()
	{
		EnterRule_start();
		EnterRule("start", 1);
		TraceIn("start", 1);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken EOF2 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> assignment1 = default(AstParserRuleReturnScope<object, IToken>);

	    object EOF2_tree = default(object);
	    RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
	    RewriteRuleSubtreeStream stream_assignment=new RewriteRuleSubtreeStream(adaptor,"rule assignment");
		try { DebugEnterRule(GrammarFileName, "start");
		DebugLocation(14, 31);
		try
		{
			// C:\\Users\\Robert Hencke\\Documents\\vgui.g:15:2: ( assignment EOF -> assignment )
			DebugEnterAlt(1);
			// C:\\Users\\Robert Hencke\\Documents\\vgui.g:15:4: assignment EOF
			{
			DebugLocation(15, 4);
			PushFollow(Follow._assignment_in_start48);
			assignment1=assignment();
			PopFollow();

			stream_assignment.Add(assignment1.Tree);
			DebugLocation(15, 15);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_start50);  
			stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: assignment
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 15:19: -> assignment
			{
				DebugLocation(15, 22);
				adaptor.AddChild(root_0, stream_assignment.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("start", 1);
			LeaveRule("start", 1);
			LeaveRule_start();
	    }
	 	DebugLocation(15, 31);
		} finally { DebugExitRule(GrammarFileName, "start"); }
		return retval;

	}
	// $ANTLR end "start"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_assignment() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_assignment() {}

	// $ANTLR start "assignment"
	// C:\\Users\\Robert Hencke\\Documents\\vgui.g:17:1: assignment : (ident= STRING TAG '=' v= value -> ^( ASSIGNMENT $ident $v TAG ) |ident= STRING '=' TAG v= value -> ^( ASSIGNMENT $ident $v TAG ) |ident= STRING '=' v= value ( TAG )? -> ^( ASSIGNMENT $ident $v ( TAG )? ) |ident= STRING TAG v= value -> ^( ASSIGNMENT $ident $v TAG ) |ident= STRING v= value ( TAG )? -> ^( ASSIGNMENT $ident $v ( TAG )? ) );
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<object, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 2);
		TraceIn("assignment", 2);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken ident = default(IToken);
	    IToken TAG3 = default(IToken);
	    IToken char_literal4 = default(IToken);
	    IToken char_literal5 = default(IToken);
	    IToken TAG6 = default(IToken);
	    IToken char_literal7 = default(IToken);
	    IToken TAG8 = default(IToken);
	    IToken TAG9 = default(IToken);
	    IToken TAG10 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> v = default(AstParserRuleReturnScope<object, IToken>);

	    object ident_tree = default(object);
	    object TAG3_tree = default(object);
	    object char_literal4_tree = default(object);
	    object char_literal5_tree = default(object);
	    object TAG6_tree = default(object);
	    object char_literal7_tree = default(object);
	    object TAG8_tree = default(object);
	    object TAG9_tree = default(object);
	    object TAG10_tree = default(object);
	    RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
	    RewriteRuleITokenStream stream_TAG=new RewriteRuleITokenStream(adaptor,"token TAG");
	    RewriteRuleITokenStream stream_11=new RewriteRuleITokenStream(adaptor,"token 11");
	    RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value");
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(17, 1);
		try
		{
			// C:\\Users\\Robert Hencke\\Documents\\vgui.g:18:2: (ident= STRING TAG '=' v= value -> ^( ASSIGNMENT $ident $v TAG ) |ident= STRING '=' TAG v= value -> ^( ASSIGNMENT $ident $v TAG ) |ident= STRING '=' v= value ( TAG )? -> ^( ASSIGNMENT $ident $v ( TAG )? ) |ident= STRING TAG v= value -> ^( ASSIGNMENT $ident $v TAG ) |ident= STRING v= value ( TAG )? -> ^( ASSIGNMENT $ident $v ( TAG )? ) )
			int alt3=5;
			try { DebugEnterDecision(3, decisionCanBacktrack[3]);
			int LA3_0 = input.LA(1);

			if ((LA3_0==STRING))
			{
				switch (input.LA(2))
				{
				case TAG:
					{
					int LA3_2 = input.LA(3);

					if ((LA3_2==11))
					{
						alt3 = 1;
					}
					else if ((LA3_2==STRING||LA3_2==12))
					{
						alt3 = 4;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case 11:
					{
					int LA3_3 = input.LA(3);

					if ((LA3_3==TAG))
					{
						alt3 = 2;
					}
					else if ((LA3_3==STRING||LA3_3==12))
					{
						alt3 = 3;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case STRING:
				case 12:
					{
					alt3 = 5;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:18:4: ident= STRING TAG '=' v= value
				{
				DebugLocation(18, 9);
				ident=(IToken)Match(input,STRING,Follow._STRING_in_assignment66);  
				stream_STRING.Add(ident);

				DebugLocation(18, 17);
				TAG3=(IToken)Match(input,TAG,Follow._TAG_in_assignment68);  
				stream_TAG.Add(TAG3);

				DebugLocation(18, 21);
				char_literal4=(IToken)Match(input,11,Follow._11_in_assignment70);  
				stream_11.Add(char_literal4);

				DebugLocation(18, 26);
				PushFollow(Follow._value_in_assignment74);
				v=value();
				PopFollow();

				stream_value.Add(v.Tree);


				{
				// AST REWRITE
				// elements: v, TAG, ident
				// token labels: ident
				// rule labels: v, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_ident=new RewriteRuleITokenStream(adaptor,"token ident",ident);
				RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 18:34: -> ^( ASSIGNMENT $ident $v TAG )
				{
					DebugLocation(18, 37);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:18:37: ^( ASSIGNMENT $ident $v TAG )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(18, 39);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASSIGNMENT, "ASSIGNMENT"), root_1);

					DebugLocation(18, 51);
					adaptor.AddChild(root_1, stream_ident.NextNode());
					DebugLocation(18, 58);
					adaptor.AddChild(root_1, stream_v.NextTree());
					DebugLocation(18, 60);
					adaptor.AddChild(root_1, stream_TAG.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:19:4: ident= STRING '=' TAG v= value
				{
				DebugLocation(19, 9);
				ident=(IToken)Match(input,STRING,Follow._STRING_in_assignment96);  
				stream_STRING.Add(ident);

				DebugLocation(19, 17);
				char_literal5=(IToken)Match(input,11,Follow._11_in_assignment98);  
				stream_11.Add(char_literal5);

				DebugLocation(19, 21);
				TAG6=(IToken)Match(input,TAG,Follow._TAG_in_assignment100);  
				stream_TAG.Add(TAG6);

				DebugLocation(19, 26);
				PushFollow(Follow._value_in_assignment104);
				v=value();
				PopFollow();

				stream_value.Add(v.Tree);


				{
				// AST REWRITE
				// elements: v, ident, TAG
				// token labels: ident
				// rule labels: v, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_ident=new RewriteRuleITokenStream(adaptor,"token ident",ident);
				RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 19:34: -> ^( ASSIGNMENT $ident $v TAG )
				{
					DebugLocation(19, 37);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:19:37: ^( ASSIGNMENT $ident $v TAG )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(19, 39);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASSIGNMENT, "ASSIGNMENT"), root_1);

					DebugLocation(19, 51);
					adaptor.AddChild(root_1, stream_ident.NextNode());
					DebugLocation(19, 58);
					adaptor.AddChild(root_1, stream_v.NextTree());
					DebugLocation(19, 60);
					adaptor.AddChild(root_1, stream_TAG.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:20:4: ident= STRING '=' v= value ( TAG )?
				{
				DebugLocation(20, 9);
				ident=(IToken)Match(input,STRING,Follow._STRING_in_assignment126);  
				stream_STRING.Add(ident);

				DebugLocation(20, 17);
				char_literal7=(IToken)Match(input,11,Follow._11_in_assignment128);  
				stream_11.Add(char_literal7);

				DebugLocation(20, 22);
				PushFollow(Follow._value_in_assignment132);
				v=value();
				PopFollow();

				stream_value.Add(v.Tree);
				DebugLocation(20, 29);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:20:29: ( TAG )?
				int alt1=2;
				try { DebugEnterSubRule(1);
				try { DebugEnterDecision(1, decisionCanBacktrack[1]);
				int LA1_0 = input.LA(1);

				if ((LA1_0==TAG))
				{
					alt1 = 1;
				}
				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:20:29: TAG
					{
					DebugLocation(20, 29);
					TAG8=(IToken)Match(input,TAG,Follow._TAG_in_assignment134);  
					stream_TAG.Add(TAG8);


					}
					break;

				}
				} finally { DebugExitSubRule(1); }



				{
				// AST REWRITE
				// elements: v, ident, TAG
				// token labels: ident
				// rule labels: v, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_ident=new RewriteRuleITokenStream(adaptor,"token ident",ident);
				RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 20:35: -> ^( ASSIGNMENT $ident $v ( TAG )? )
				{
					DebugLocation(20, 38);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:20:38: ^( ASSIGNMENT $ident $v ( TAG )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(20, 40);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASSIGNMENT, "ASSIGNMENT"), root_1);

					DebugLocation(20, 52);
					adaptor.AddChild(root_1, stream_ident.NextNode());
					DebugLocation(20, 59);
					adaptor.AddChild(root_1, stream_v.NextTree());
					DebugLocation(20, 61);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:20:61: ( TAG )?
					if (stream_TAG.HasNext)
					{
						DebugLocation(20, 61);
						adaptor.AddChild(root_1, stream_TAG.NextNode());

					}
					stream_TAG.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:21:4: ident= STRING TAG v= value
				{
				DebugLocation(21, 9);
				ident=(IToken)Match(input,STRING,Follow._STRING_in_assignment158);  
				stream_STRING.Add(ident);

				DebugLocation(21, 17);
				TAG9=(IToken)Match(input,TAG,Follow._TAG_in_assignment160);  
				stream_TAG.Add(TAG9);

				DebugLocation(21, 22);
				PushFollow(Follow._value_in_assignment164);
				v=value();
				PopFollow();

				stream_value.Add(v.Tree);


				{
				// AST REWRITE
				// elements: TAG, ident, v
				// token labels: ident
				// rule labels: v, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_ident=new RewriteRuleITokenStream(adaptor,"token ident",ident);
				RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 21:29: -> ^( ASSIGNMENT $ident $v TAG )
				{
					DebugLocation(21, 32);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:21:32: ^( ASSIGNMENT $ident $v TAG )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(21, 34);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASSIGNMENT, "ASSIGNMENT"), root_1);

					DebugLocation(21, 46);
					adaptor.AddChild(root_1, stream_ident.NextNode());
					DebugLocation(21, 53);
					adaptor.AddChild(root_1, stream_v.NextTree());
					DebugLocation(21, 55);
					adaptor.AddChild(root_1, stream_TAG.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:22:4: ident= STRING v= value ( TAG )?
				{
				DebugLocation(22, 9);
				ident=(IToken)Match(input,STRING,Follow._STRING_in_assignment185);  
				stream_STRING.Add(ident);

				DebugLocation(22, 18);
				PushFollow(Follow._value_in_assignment189);
				v=value();
				PopFollow();

				stream_value.Add(v.Tree);
				DebugLocation(22, 25);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:22:25: ( TAG )?
				int alt2=2;
				try { DebugEnterSubRule(2);
				try { DebugEnterDecision(2, decisionCanBacktrack[2]);
				int LA2_0 = input.LA(1);

				if ((LA2_0==TAG))
				{
					alt2 = 1;
				}
				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:22:25: TAG
					{
					DebugLocation(22, 25);
					TAG10=(IToken)Match(input,TAG,Follow._TAG_in_assignment191);  
					stream_TAG.Add(TAG10);


					}
					break;

				}
				} finally { DebugExitSubRule(2); }



				{
				// AST REWRITE
				// elements: v, TAG, ident
				// token labels: ident
				// rule labels: v, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_ident=new RewriteRuleITokenStream(adaptor,"token ident",ident);
				RewriteRuleSubtreeStream stream_v=new RewriteRuleSubtreeStream(adaptor,"rule v",v!=null?v.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 22:30: -> ^( ASSIGNMENT $ident $v ( TAG )? )
				{
					DebugLocation(22, 33);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:22:33: ^( ASSIGNMENT $ident $v ( TAG )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(22, 35);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASSIGNMENT, "ASSIGNMENT"), root_1);

					DebugLocation(22, 47);
					adaptor.AddChild(root_1, stream_ident.NextNode());
					DebugLocation(22, 54);
					adaptor.AddChild(root_1, stream_v.NextTree());
					DebugLocation(22, 56);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:22:56: ( TAG )?
					if (stream_TAG.HasNext)
					{
						DebugLocation(22, 56);
						adaptor.AddChild(root_1, stream_TAG.NextNode());

					}
					stream_TAG.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 2);
			LeaveRule("assignment", 2);
			LeaveRule_assignment();
	    }
	 	DebugLocation(23, 1);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_value() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_value() {}

	// $ANTLR start "value"
	// C:\\Users\\Robert Hencke\\Documents\\vgui.g:26:1: value : ( STRING | assignmentGroup );
	[GrammarRule("value")]
	private AstParserRuleReturnScope<object, IToken> value()
	{
		EnterRule_value();
		EnterRule("value", 3);
		TraceIn("value", 3);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken STRING11 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> assignmentGroup12 = default(AstParserRuleReturnScope<object, IToken>);

	    object STRING11_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "value");
		DebugLocation(26, 1);
		try
		{
			// C:\\Users\\Robert Hencke\\Documents\\vgui.g:26:7: ( STRING | assignmentGroup )
			int alt4=2;
			try { DebugEnterDecision(4, decisionCanBacktrack[4]);
			int LA4_0 = input.LA(1);

			if ((LA4_0==STRING))
			{
				alt4 = 1;
			}
			else if ((LA4_0==12))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:26:9: STRING
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(26, 9);
				STRING11=(IToken)Match(input,STRING,Follow._STRING_in_value219); 
				STRING11_tree = (object)adaptor.Create(STRING11);
				adaptor.AddChild(root_0, STRING11_tree);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:27:4: assignmentGroup
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(27, 4);
				PushFollow(Follow._assignmentGroup_in_value224);
				assignmentGroup12=assignmentGroup();
				PopFollow();

				adaptor.AddChild(root_0, assignmentGroup12.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value", 3);
			LeaveRule("value", 3);
			LeaveRule_value();
	    }
	 	DebugLocation(28, 1);
		} finally { DebugExitRule(GrammarFileName, "value"); }
		return retval;

	}
	// $ANTLR end "value"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_assignmentGroup() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_assignmentGroup() {}

	// $ANTLR start "assignmentGroup"
	// C:\\Users\\Robert Hencke\\Documents\\vgui.g:30:1: assignmentGroup : '{' ( assignment )* '}' -> ^( GROUP ( assignment )* ) ;
	[GrammarRule("assignmentGroup")]
	private AstParserRuleReturnScope<object, IToken> assignmentGroup()
	{
		EnterRule_assignmentGroup();
		EnterRule("assignmentGroup", 4);
		TraceIn("assignmentGroup", 4);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken char_literal13 = default(IToken);
	    IToken char_literal15 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> assignment14 = default(AstParserRuleReturnScope<object, IToken>);

	    object char_literal13_tree = default(object);
	    object char_literal15_tree = default(object);
	    RewriteRuleITokenStream stream_13=new RewriteRuleITokenStream(adaptor,"token 13");
	    RewriteRuleITokenStream stream_12=new RewriteRuleITokenStream(adaptor,"token 12");
	    RewriteRuleSubtreeStream stream_assignment=new RewriteRuleSubtreeStream(adaptor,"rule assignment");
		try { DebugEnterRule(GrammarFileName, "assignmentGroup");
		DebugLocation(30, 1);
		try
		{
			// C:\\Users\\Robert Hencke\\Documents\\vgui.g:31:2: ( '{' ( assignment )* '}' -> ^( GROUP ( assignment )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\Robert Hencke\\Documents\\vgui.g:31:4: '{' ( assignment )* '}'
			{
			DebugLocation(31, 4);
			char_literal13=(IToken)Match(input,12,Follow._12_in_assignmentGroup235);  
			stream_12.Add(char_literal13);

			DebugLocation(31, 8);
			// C:\\Users\\Robert Hencke\\Documents\\vgui.g:31:8: ( assignment )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, decisionCanBacktrack[5]);
				int LA5_0 = input.LA(1);

				if ((LA5_0==STRING))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\Robert Hencke\\Documents\\vgui.g:31:8: assignment
					{
					DebugLocation(31, 8);
					PushFollow(Follow._assignment_in_assignmentGroup237);
					assignment14=assignment();
					PopFollow();

					stream_assignment.Add(assignment14.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(31, 20);
			char_literal15=(IToken)Match(input,13,Follow._13_in_assignmentGroup240);  
			stream_13.Add(char_literal15);



			{
			// AST REWRITE
			// elements: assignment
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 31:24: -> ^( GROUP ( assignment )* )
			{
				DebugLocation(31, 27);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:31:27: ^( GROUP ( assignment )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(31, 29);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(GROUP, "GROUP"), root_1);

				DebugLocation(31, 35);
				// C:\\Users\\Robert Hencke\\Documents\\vgui.g:31:35: ( assignment )*
				while ( stream_assignment.HasNext )
				{
					DebugLocation(31, 35);
					adaptor.AddChild(root_1, stream_assignment.NextTree());

				}
				stream_assignment.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentGroup", 4);
			LeaveRule("assignmentGroup", 4);
			LeaveRule_assignmentGroup();
	    }
	 	DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentGroup"); }
		return retval;

	}
	// $ANTLR end "assignmentGroup"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _assignment_in_start48 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_start50 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_assignment66 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _TAG_in_assignment68 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _11_in_assignment70 = new BitSet(new ulong[]{0x1100UL});
		public static readonly BitSet _value_in_assignment74 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_assignment96 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _11_in_assignment98 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _TAG_in_assignment100 = new BitSet(new ulong[]{0x1100UL});
		public static readonly BitSet _value_in_assignment104 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_assignment126 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _11_in_assignment128 = new BitSet(new ulong[]{0x1100UL});
		public static readonly BitSet _value_in_assignment132 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _TAG_in_assignment134 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_assignment158 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _TAG_in_assignment160 = new BitSet(new ulong[]{0x1100UL});
		public static readonly BitSet _value_in_assignment164 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_assignment185 = new BitSet(new ulong[]{0x1100UL});
		public static readonly BitSet _value_in_assignment189 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _TAG_in_assignment191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_value219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentGroup_in_value224 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _12_in_assignmentGroup235 = new BitSet(new ulong[]{0x2100UL});
		public static readonly BitSet _assignment_in_assignmentGroup237 = new BitSet(new ulong[]{0x2100UL});
		public static readonly BitSet _13_in_assignmentGroup240 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
